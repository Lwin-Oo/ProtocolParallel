# ğŸš€ Day 3: STL Containers, Iterators, and Algorithms

---

## ğŸ“Š STL Containers: What They Are, How They Work, and When to Use

### ğŸ”¹ `std::vector<T>`

> ğŸ”§ **Think:** dynamic array with fast appends and indexed access

#### âœ… Use When:

* We need to **store data in order**
* We want **random access**: `vec[i]`
* We expect **more reads than writes**
* We want **fast iteration**

#### âš™ï¸ Memory:

* Elements are stored **contiguously in memory**
* Backed by a dynamic heap array that **doubles in capacity** when full
* **Amortized O(1)** for `push_back()`, but **O(n)** for insertion elsewhere

#### ğŸ”¥ Use Cases:

* Contact list
* Game entity pool
* Camera frame buffer
* Neural layer activations (in ML engines)

---

### ğŸ”¹ `std::list<T>` *(comparison only)*

* Doubly linked list
* Insert/delete in middle: âœ…
* Bad cache locality: âŒ
* Only used in niche cases like memory pools or task queues with frequent splicing

---

### ğŸ”¹ `std::map<Key, Value>`

> ğŸ”§ **Think:** red-black tree with sorted keys

#### âœ… Use When:

* You need key-value pairs **in order**
* You want **logarithmic insertion/search** (O(log n))
* You require deterministic iteration order

#### âš™ï¸ Memory:

* Tree nodes on heap (not contiguous)
* Moderate overhead

#### ğŸ”¥ Use Cases:

* Sorted leaderboard
* Symbol table in compiler
* Timestamp-based data stream

---

### ğŸ”¹ `std::unordered_map<Key, Value>`

> ğŸ”§ **Think:** hash table for key-value

#### âœ… Use When:

* You need **blazing fast lookup** (avg. O(1))
* Don't care about order
* Scale across huge datasets

#### âš™ï¸ Memory:

* Buckets + hash function
* Higher memory usage for performance

#### ğŸ”¥ Use Cases:

* Indexing video frames by ID
* User sessions in web servers
* Fast graph adjacency lookups

---

### ğŸ”¹ `std::set<T>`

> ğŸ”§ **Think:** auto-sorted container of unique values

#### âœ… Use When:

* You need to **store unique items**
* Items should stay **automatically sorted**

#### âš™ï¸ Memory:

* Tree-based
* Higher overhead than unordered\_set

#### ğŸ”¥ Use Cases:

* Leaderboards
* Deduplicating log tags
* Live process registry

---

### ğŸ”¹ `std::unordered_set<T>`

> ğŸ”§ **Think:** hash-based set for fast uniqueness

#### âœ… Use When:

* You care only about **uniqueness**
* Order doesn't matter

#### ğŸ”¥ Use Cases:

* Memory-efficient user ID tracking
* Storing visited nodes in BFS/DFS
* Seen error codes in telemetry

---

### ğŸ”¹ `std::pair<T1, T2>`

> ğŸ”§ **Think:** tiny 2-field struct

#### âœ… Use When:

* Returning multiple values
* Holding two linked values together (key/value, name/score)

---

### ğŸš€ Performance Recap

| Container       | Indexable | Ordered | Unique | Fast Lookup | Memory   |
| --------------- | --------- | ------- | ------ | ----------- | -------- |
| `vector`        | âœ…         | âœ…       | âŒ      | âŒ           | Compact  |
| `map`           | âŒ         | âœ…       | âœ…      | O(log n)    | Moderate |
| `unordered_map` | âŒ         | âŒ       | âœ…      | âœ… (O(1))    | Higher   |
| `set`           | âŒ         | âœ…       | âœ…      | O(log n)    | Moderate |
| `unordered_set` | âŒ         | âŒ       | âœ…      | âœ… (O(1))    | Higher   |

---

# ğŸ“ Iterators in Modern C++

### ğŸ§  What Are Iterators?

> Safe abstractions over pointers to access containers

### ğŸ”„ Types

| Type                     | Direction | Writable | Container Examples |
| ------------------------ | --------- | -------- | ------------------ |
| `iterator`               | â†’         | Yes      | `vector`, `map`    |
| `const_iterator`         | â†’         | No       | Safe read loops    |
| `reverse_iterator`       | â†         | Yes      | Undo systems, logs |
| `const_reverse_iterator` | â†         | No       | Scrollback viewers |

---

### ğŸ”¹ Manual Iterator Example

```cpp
std::vector<std::string> names = {"Alice", "Bob", "Carl"};
for (auto it = names.begin(); it != names.end(); ++it) {
    std::cout << *it << "\n";
}
```

---

### ğŸ”¹ Range Loop (Modern Way)

```cpp
for (const auto& name : names) {
    std::cout << name << "\n";
}
```

---

## ğŸ”¢ STL Algorithms (Header: `<algorithm>`, `<numeric>`)

### ğŸ”¹ `std::find` / `std::find_if`

```cpp
std::find(vec.begin(), vec.end(), target);
std::find_if(vec.begin(), vec.end(), [](int x) { return x > 10; });
```

* âœ… Linear search
* âœ… Great for filtering

---

### ğŸ”¹ `std::sort`

```cpp
std::sort(vec.begin(), vec.end());
std::sort(vec.begin(), vec.end(), [](auto& a, auto& b) {
    return a.name < b.name;
});
```

* Uses intro sort (quick + heap + insertion)
* Fast and safe

---

### ğŸ”¹ `std::count_if`

```cpp
int count = std::count_if(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; });
```

* âœ… Useful for analytics
* âœ… Like map-reduce for counts

---

### ğŸ”¹ `std::for_each`

```cpp
std::for_each(vec.begin(), vec.end(), [](const auto& x){ std::cout << x; });
```

* âœ… Good for applying operations without writing full loop

---

### ğŸ”¹ `std::accumulate` (from `<numeric>`)

```cpp
int sum = std::accumulate(vec.begin(), vec.end(), 0);
```

* âœ… Compact reduce pattern
* âœ… Used for prefix sums, scoring, energy consumption, etc.

---

### ğŸš€ Performance Consideration

* All STL algorithms use **iterators**, not indexes
* Works on **any container**, including `list`, `map`, etc.
* Often **faster and cleaner than raw loops**

---

### ğŸ”¥ Real Parallel Computing Use Cases

* `count_if()` to count active threads
* `find_if()` to identify jobs needing migration
* `accumulate()` to reduce metrics from cores
* `unordered_map` for thread-safe state tables (with mutex)
* `set` for de-duplicating GPU kernels by signature

---

## ğŸ“… Final Summary

> Containers + Iterators + Algorithms = C++'s Modern Power Trio

* Containers manage memory and order
* Iterators safely walk memory like pro pointers
* Algorithms let you think in *what*, not *how*