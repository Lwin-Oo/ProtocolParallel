# üöÄ Day 2: Smart Pointers & RAII

> **Goal:** Never `delete` again. Own memory safely. Understand **RAII**, **unique\_ptr**, **shared\_ptr**, and **weak\_ptr**.

---

## üìò What We'll Learn

| Concept       | Description                                                               |
| ------------- | ------------------------------------------------------------------------- |
| RAII          | *Resource Acquisition Is Initialization* ‚Äî memory tied to object lifetime |
| `unique_ptr`  | One owner only. Automatically deletes.                                    |
| `shared_ptr`  | Shared ownership via reference counting.                                  |
| `weak_ptr`    | Observer ‚Äî doesn‚Äôt keep memory alive.                                     |
| `make_unique` | Safest way to create `unique_ptr`                                         |
| `make_shared` | Same for `shared_ptr`                                                     |

---

## üõ†Ô∏è Classic Ownership Problem

```cpp
std::vector<Contact> contacts;

Contact c;
c.name = "Alice";
c.phone = "123";
contacts.push_back(c);
```

This stores everything by value ‚Äî no heap, no smart pointers.
But what if we want to manage memory on the heap?

---

## ‚úÖ New Approach (Smart Pointer Style)

```cpp
std::vector<std::unique_ptr<Contact>> contacts;

contacts.push_back(std::make_unique<Contact>("Alice", "123"));
```

We no longer need `delete`. No memory leaks. Clean and safe heap allocation.

---

# üßº Smart Pointer Series

## üîπ `unique_ptr`

### üéØ Mission: Build ContactBook++ V2 with `unique_ptr`

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <string>

struct Contact {
    std::string name;
    std::string phone;

    Contact(const std::string& n, const std::string& p) : name(n), phone(p) {
        std::cout << "üì¶ Contact Created: " << name << "\n";
    }

    ~Contact() {
        std::cout << "üí• Contact Destroyed: " << name << "\n";
    }
};

int main() {
    std::vector<std::unique_ptr<Contact>> contacts;

    contacts.push_back(std::make_unique<Contact>("Alice", "123"));
    contacts.push_back(std::make_unique<Contact>("Bob", "456"));
    contacts.push_back(std::make_unique<Contact>("Carl", "789"));

    std::cout << "üìá Contact List:\n";
    for (const auto& c : contacts) {
        std::cout << "- " << c->name << " (" << c->phone << ")\n";
    }

    return 0;
}
```

### üß† Summary Table for `unique_ptr`

| Concept            | Meaning                                         |
| ------------------ | ----------------------------------------------- |
| `unique_ptr`       | One-owner smart pointer ‚Äî deletes automatically |
| `make_unique`      | Safest way to create `unique_ptr` heap objects  |
| Move semantics     | Transfer ownership with `std::move`, not copy   |
| RAII               | Lifetime of object = lifetime of its memory     |
| Constructor / Dtor | Run automatically on create/destroy             |
| Out of scope       | End of `{}` block ‚Äî triggers cleanup            |

---

## üî∏ `shared_ptr`

### üîπ What Is `shared_ptr`

* Multiple owners ‚Äî shared ownership
* Reference counted ‚Äî memory is freed when count reaches zero
* Safe copyable smart pointer

```cpp
#include <iostream>
#include <memory>
#include <string>

struct Contact {
    std::string name;
    Contact(const std::string& n) : name(n) {
        std::cout << "üì¶ Created: " << name << "\n";
    }
    ~Contact() {
        std::cout << "üí• Destroyed: " << name << "\n";
    }
};

int main() {
    std::shared_ptr<Contact> p1 = std::make_shared<Contact>("Alice");

    {
        std::shared_ptr<Contact> p2 = p1;
        std::cout << "Ref count: " << p1.use_count() << "\n";
    }

    std::cout << "Ref count: " << p1.use_count() << "\n";
}
```

### üß† Summary Table for `shared_ptr`

| Concept       | Meaning                                             |
| ------------- | --------------------------------------------------- |
| `shared_ptr`  | Shared smart pointer with reference counting        |
| `make_shared` | Efficient way to allocate + share memory            |
| Ref count     | Keeps object alive until all owners go out of scope |
| Safe copy     | Can be copied between functions and modules         |
| Cleanup       | Happens when last owner is gone                     |

---

## üî∏ `weak_ptr`

### üîπ What Is `weak_ptr`

* A **non-owning** smart pointer that observes a `shared_ptr`.
* It does **not affect** the reference count of a `shared_ptr`.
* Prevents **cyclic references** (e.g. `A -> B -> A`) that would leak memory.
* You use `weak_ptr` to **safely reference** shared memory **without extending its lifetime**.

```cpp
#include <iostream>
#include <memory>
#include <string>

struct Contact {
    std::string name;
    Contact(const std::string& n) : name(n) {
        std::cout << "üì¶ Created: " << name << "\n";
    }
    ~Contact() {
        std::cout << "üí• Destroyed: " << name << "\n";
    }
};

int main() {
    std::shared_ptr<Contact> p1 = std::make_shared<Contact>("Alice");
    std::weak_ptr<Contact> observer = p1;

    std::cout << "Ref count: " << p1.use_count() << "\n";

    if (auto locked = observer.lock()) {
        std::cout << "Observer sees: " << locked->name << "\n";
    }

    p1.reset();

    if (auto locked = observer.lock()) {
        std::cout << "Observer sees: " << locked->name << "\n";
    } else {
        std::cout << "Observer sees: [expired]\n";
    }
}
```

### üß† Summary Table for `weak_ptr`

| Concept          | Meaning                                                    |
| ---------------- | ---------------------------------------------------------- |
| `weak_ptr`       | Observer pointer ‚Äî doesn‚Äôt extend object lifetime          |
| No ref count inc | Safe to observe shared\_ptr without affecting cleanup      |
| `.lock()`        | Temporarily promotes to shared\_ptr if still alive         |
| Best use case    | Avoiding cycles or referencing shared objects non-owningly |

---

## üß† Core Idea Recap

| Pointer      | Key Trait                  | Behavior                      |
| ------------ | -------------------------- | ----------------------------- |
| `unique_ptr` | Exclusive ownership        | One owner, fast, non-copyable |
| `shared_ptr` | Shared ownership           | Multiple owners, ref-counted  |
| `weak_ptr`   | Observer only (non-owning) | Doesn't keep object alive     |

---

## ‚öôÔ∏è System-Level Impact

### üîπ Performance

| Pointer Type | Cost per Access | Why                                          |
| ------------ | --------------- | -------------------------------------------- |
| `unique_ptr` | ‚úÖ Almost zero   | Just a raw pointer with auto-delete on scope |
| `shared_ptr` | ‚ùå Higher        | Atomic ref count operations on copy/move     |
| `weak_ptr`   | ‚ö†Ô∏è Slight Cost  | Must check/lock shared control block         |

---

### üîπ Memory Model

* `unique_ptr`: 1 pointer ‚Üí 1 object
* `shared_ptr`: 1 control block + object + ref count
* `weak_ptr`: links to shared\_ptr‚Äôs control block without ownership

---

### üîπ Lifetime Clarity

| Behavior             | `unique_ptr`              | `shared_ptr`                      | `weak_ptr`                      |
| -------------------- | ------------------------- | --------------------------------- | ------------------------------- |
| Who owns it?         | Always clear ‚Äî the holder | Could be many ‚Äî use `use_count()` | Nobody ‚Äî observer only          |
| Lifetime prediction? | ‚úÖ Easy                    | ‚ùå Hard (shared across modules)    | ‚úÖ Safe ‚Äî doesn‚Äôt prolong object |

---

### üîπ Thread Safety

* `shared_ptr`: thread-safe ref count
* `weak_ptr`: thread-safe lock
* `unique_ptr`: not thread-safe by default

---

## ‚úÖ When to Use

| Scenario                              | Use                            |
| ------------------------------------- | ------------------------------ |
| Embedded systems, game loops          | ‚úÖ `unique_ptr`                 |
| One producer, one consumer            | ‚úÖ `unique_ptr` + `std::move()` |
| Plugin systems, shared resources      | ‚úÖ `shared_ptr`                 |
| Observer pattern / parent-child graph | ‚úÖ `shared_ptr` + `weak_ptr`    |
